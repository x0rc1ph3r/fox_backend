// Base configuration for Prisma
// This file contains the generator and datasource configuration

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Entry {
  id           Int @id @default(autoincrement())
  userAddress  String
  raffleId     Int
  quantity     Int    @default(1)

  user         User   @relation("UserEntries", fields: [userAddress], references: [walletAddress], onDelete: Cascade, map: "entries_user_fkey")
  raffle       Raffle @relation("RaffleEntries", fields: [raffleId], references: [id], onDelete: Cascade, map: "entries_raffle_fkey")
  transactions Transaction[] @relation("TransactionEntry")
  @@map("entries")
  @@index([userAddress])
  @@index([raffleId])
  @@unique([userAddress, raffleId])
}

enum PrizeDataType {
  TOKEN
  NFT
}

model PrizeData {
  id          Int     @id @default(autoincrement())
  type        PrizeDataType @default(TOKEN)
  address     String
  mintAddress String
  mint        String
  name        String
  verified    Boolean @default(true)
  symbol      String
  decimals    Int?
  image       String
  attributes  Json?
  collection  String?
  creator     String?
  description String?
  externalUrl String?
  properties  Json?
  raffleId    Int     @unique
  amount      Float? //amount for SPL tokens
  floor       Float? //floor price for nft

  raffle      Raffle  @relation("RafflePrize", fields: [raffleId], references: [id], onDelete: Cascade)
  @@map("prize_data")
  @@index([mint])
  @@index([creator])
}

enum RaffleState {
  None
  Initialized
  Active
  Cancelled
  SuccessEnded
  FailedEnded
}

model Raffle {
  id                 Int         @id @default(autoincrement())
  raffle             String?     @unique //raffle address to be fetched later
  createdAt          DateTime    @default(now())
  endsAt             DateTime
  state              RaffleState @default(None)
  createdBy          String
  ticketPrice        Float
  ticketTokenSymbol  String      @default("Sol")
  ticketTokenAddress String      @default("So11111111111111111111111111111111111111112")
  ticketSupply       Int
  ticketSold         Int         @default(0)
  claimed            Int         @default(0)
  numberOfWinners    Int         @default(1)
  winnerPicked       Boolean     @default(false)
  floor              Float?
  val                Float?
  ttv                Float
  roi                Float
  entriesAddress     String? //entries address to be fetched later
  prize              String? //pize address to be fetched later
  maxEntries         Int
  totalEntries       Int         @default(0)

  creator       User        @relation("RaffleCreator", fields: [createdBy], references: [walletAddress], onDelete: Cascade)
  favouritedBy  User[]      @relation("FavouriteRaffle")
  winners       User[]      @relation("RaffleWinner")
  raffleEntries Entry[]     @relation("RaffleEntries")
  prizeData     PrizeData?  @relation("RafflePrize")
  transactions Transaction[] @relation("TransactionRaffle")
  @@index([createdBy])
  @@index([raffle])
  @@index([endsAt])
  @@map("raffles")
}

enum TransactionType {
  RAFFLE_CREATION
  RAFFLE_ENTRY
  RAFFLE_WIN
  RAFFLE_CANCEL
  RAFFLE_END
  RAFFLE_CLAIM
  RAFFLE_REFUND
  RAFFLE_PURCHASE
  RAFFLE_DEPOSIT
}

model Transaction {
  id            String          @id @default(uuid())
  transactionId String          @unique
  type          TransactionType
  sender        String
  receiver      String
  createdAt     DateTime        @default(now())
  amount        BigInt
  isNft         Boolean         @default(false)
  mintAddress   String          //a unified field for both token and nft transactions
  metadata      Json?           //metadata for the transaction
  
  entryId       Int?            
  raffleId      Int?            
  entry       Entry?            @relation("TransactionEntry", fields: [entryId], references: [id])
  raffle      Raffle?           @relation("TransactionRaffle", fields: [raffleId], references: [id])
  
  user          User            @relation(fields: [sender], references: [walletAddress])
  @@map("transactions")
  @@index([sender])
  @@index([receiver])
  @@index([transactionId])
  @@index([entryId])
  @@index([raffleId])
}

model User {
  id                String   @id @default(uuid())
  walletAddress     String   @unique
  createdAt         DateTime @default(now())
  twitterId         String?   @unique
  twitterConnected  Boolean  @default(false)
  rafflesCreated    Raffle[]     @relation("RaffleCreator")
  favouriteRaffles  Raffle[]     @relation("FavouriteRaffle")
  raffleEntries     Entry[]       @relation("UserEntries")
  transactions      Transaction[]
  raffleWinnings    Raffle[]      @relation("RaffleWinner")
 
  @@map("users")
  @@index([walletAddress])
}
